---
title: fp-ts for the Rest of Us
tagline: Time to begin the Airing of Grievances
tags:
  - fp-ts
  - functional programming
  - TypeScript
---

# Airing of Grievances

OK, so you've heard about `fp-ts` or functional programming somewhere. Maybe you're curious to learn it, or
maybe you heard that it could be a helpful tool, or maybe you were forced to use it because something
else you're using depends on `fp-ts`. 

Either way, let's go ahead and open up the [fp-ts docs](https://gcanti.github.io/fp-ts/)! Ah, here we go, it says...

> Disclaimer. Teaching functional programming is out of scope of this project, so the documentation 
assumes you already know what FP is.

Umm, OK. A bit ominous, but not a big deal. We've figured things out from looking at the docs before, right?
Let's take a look down the [modules](https://gcanti.github.io/fp-ts/modules/) list and take
a look at the first one that's familiar.

Ahh, [Apply](https://gcanti.github.io/fp-ts/modules/Apply.ts.html) sounds good! We know about
`Function.prototype.apply`, and that's kind of functional-ish (well, it has **Function** in the name),
so this will probably be similar, right? OK, let's take a look:

> Instances must satisfy the following law in addition to the Functor laws:
> * Associative composition: `F.ap(F.ap(F.map(fbc, bc => ab => a => bc(ab(a))), fab), fa) <-> F.ap(fbc, F.ap(fab, fa))`
> Formally, Apply represents a strong lax semi-monoidal endofunctor.

[WTF man gif]

Ignoring those funny words (whatever they mean!) we can't even make heads or tails of the code. It's [gobbledygook](https://www.vocabulary.com/dictionary/gobbledygook)!
What's all this stuff? `fbc`? `<->`? `bc(ab(a))`? Why does it have to be so **hard**?

# Feats of Strength

Now that the Airing of Grievances is over, let's begin the Feats of Strength! This will be by far the longest section of
this article.

First off, we need to get familiar with some notation. Being able to read the documentation is half
the battle!

Let's start with a little TypeScript<Footnote>1</Footnote>:

```ts
type MyType = {
    transform: (a: A) => B
}
```

To write this out: A value that is type `MyType` has a `transform` function. That `transform` function takes a 
parameter of type `A` and returns a parameter of type `B`.

TypeScript uses the syntax `(a: A) => B` for the function signature. If you think about it though, the lowercase
`a` is unnecessary -- TypeScript doesn't actually care what we name our parameter. So going forwards we'll say `A => B`
is a function that has an input of type `A` and an output of type `B`.

Let's take a look at our first `fp-ts` type, the Semigroup.

## Semigroup

[fp-ts Semigroup documentation](https://gcanti.github.io/fp-ts/modules/Semigroup.ts.html)

### Semigroup - What is it?

A Semigroup is a thing which can be combined with another thing of the same type to produce another
thing of the same type.

<SkepticalSkunk>
Ok... this doesn't sound that interesting... maybe an example?
</SkepticalSkunk>

```TypeScript
10 + 20
```

A `number` (with respect to addition) is an example of a Semigroup because it can be combined
(added) to a `number` which produces another `number`.

Semigroups must satisfy the [Associative property](https://en.wikipedia.org/wiki/Associative_property),
for example:

```JavaScript
(10 + 20) + 30 === 10 + (20 + 30)
```

The `fp-ts` documentation linked above implements a Semigroup as:

```TypeScript
interface Semigroup<A> {
  readonly concat: (x: A, y: A) => A
}
```

<CuriousBeaver>
Arrays in JavaScript are Semigroups?
</CuriousBeaver>

That's right! JavaScript arrays can be combined (concatenated) with other arrays to produce arrays.
The concatenation is associative, meaning that:

```JavaScript
// This order of concatenation
( arr1.concat(arr2) ).concat(arr3)

// is equivalent to this order of concatentation
arr1.concat( arr2.concat(arr3) )
```

String concatenation is associative also.

<SkepticalSkunk>
Hold on a minute... you said that numbers and strings are Semigroups, and yet they don't have a <code>concat</code> 
function! And the Array <code>concat</code> function takes one parameter, not two.  What gives?
</SkepticalSkunk>

Great question, we should also distinguish between two cases:

1. Certain types of data are discovered to be Semigroups because they fulfill the mathematical requirements to be a Semigroup
2. The `fp-ts` library **implementation of** this concept

The `fp-ts` documentation linked above also contains an example how a string semigroup can be defined in terms of the `fp-ts`
implementation.

### Semigroup - What isn't it?

While many primitives are Semigroups, not everything is a Semigroup including many/most user-defined types. 

Consider a hypothetical `Invoice`:

```TypeScript
type Invoice = {
  customer: Customer
  vendor: Vendor
  products: Product[]
  amount: number
  shipping: ShippingDetails
}
```

An `Invoice` doesn't have a meaningful way to be combined with another `Invoice` to produce an `Invoice` (what would it mean
to add a `Vendor` to another `Vendor`?). However, certain properties of the `Invoice` are Semigroups, such as the `amount` field
which is a `number`.

### Semigroup - Why does it matter?

When evaluating a concept for usefulness (why does it matter?) there are many considerations, but it somewhat comes down to these two:

* **Practical**: Can I use this concept directly in my program/application/library?
* **Conceptual**: Will knowing this concept help me understand another concept which has practical implications?

Either or both can be valuable.

An example of the **practical** implications of the Semigroup is directly related to its Associative property. In the example below,
given that the variables are an instance of some `S` which is a Semigroup, we said that this is true:

```JavaScript
s1 + (s2 + s3) === (s1 + s2) + s3
```

At the surface level, this seems trivial, but it's quite significant because this grants _safe parallelization_. The combinations
can be calculated in any order (so could be calculated on different threads, processes, or even machines) and the final result will
be the same, guaranteed because of the underlying mathematical concepts. While this example with `number`s **is** trivial, applying
the same concept to any large calculation or batch job could be a significant help in reasoning about parallel code.

At a **conceptual** level, we've already learned a lot just from this first example (phew! Great job for making it this far!). We
have learned:

* A bit of notation of the `fp-ts` library (we'll see more still)
* Functional programming concepts are composed of mathematical concepts
* We can start with the fundamentals and slowly build those up into a larger understanding

Let's now meet the next member of the crew, the `Monoid`.

## Monoid

[fp-ts Monoid documentation](https://gcanti.github.io/fp-ts/modules/Monoid.ts.html)

### Monoid - What is it?

A `Monoid` is a Semigroup that also has an "empty" value.

Examples of "empty" values are:

* Empty string (`""`) for strings
* Empty array (`[]`) for arrays
* Zero `0` for numbers
* Zero `0n` for bigint

The `fp-ts` library implements a `Monoid` as:

```TypeScript
interface Monoid<A> extends Semigroup<A> {
  readonly empty: A
}
```

<CuriousBeaver>
It seems like all of the Semigroups from before are also Monoids. Are there any Semigroups
that are <strong>not</strong> Monoids?
</CuriousBeaver>

Great question... the practical answer is - for primitives and standard types, _not really_. All of the examples we've worked with
so far have a value that can be reasonably considered as the "empty" value. Perhaps there are some user-defined types where this
might not be true. There are other theoretical answers to this question on [math.stackexchange.com](TODO), but beware, we've
only dipped our toes into the math side of things so far in this article, by clicking that link you will dive fully in.

### Monoid - Example

`Monoid` extends the definition of `Semigroup` such that the value can also be combined with the "empty" value (and due to 
the Associative property, the order of combination with "empty" does not matter). One example where this comes into play in 
JavaScript when using the `Array.prototype.reduce` function, we provide the starting (read: "empty") value as the second
argument to the function.

For a contrived example, consider an object that represents a frequency of vowels found in a sentence (let's not consider
`y` as a vowel).

```TypeScript
type VowelFrequency = {
  a: number
  e: number
  i: number
  o: number
  u: number
}
```

The "empty" value for this data type is:

```TypeScript
const emptyVowelFrequency = {
  a: 0,
  e: 0,
  i: 0,
  o: 0,
  u: 0
}
```

The concatenation function can be defined as:

```TypeScript
function concatVowelFrequencies(first: VowelFrequency, second: VowelFrequency): VowelFrequency {
  return {
    a: first.a + second.a,
    e: first.e + second.e,
    i: first.i + second.i,
    o: first.o + second.o,
    u: first.u + second.u,
  }
}
```

Finally, the monoid can be implemented using the `fp-ts` library as:

```TypeScript
import { Monoid } from 'fp-ts/Monoid'

const monoidVowelFrequencies: Monoid<VowelFrequency> = {
  concat: concatVowelFrequencies,
  empty: emptyVowelFrequency,
}
```

If we had an array of the vowel frequencies of every line in this article, we can concat/combine them all
using the utility functions provided by `fp-ts`.

```TypeScript
import { concatAll } from 'fp-ts/Monoid'

const data: VowelFrequency[] = [ /* somebody spent a while counting */ ]

// TODO: check this
const totalFrequency: VowelFrequency = concatAll(monoidVowelFrequencies)(data)
```

### Monoid - Relationship to Other Concepts

This ties into the `filter`/`map`/`reduce` paradigm as well (TODO - link?). 

<Conversation>
<CuriousBeaver>Hey, <code>filter</code>, <code>map</code>, <code>reduce</code>, I've heard of those!</CuriousBeaver>
</Conversation>

Given an array of strings for each line of this article, we can:

1. `filter`: Perhaps we only wanted to consider paragraphs and not code blocks, we'd filter first
2. `map`: Execute a `string => VowelFrequency` function to map the `string` to the frequency
3. `reduce`: Execute a `(VowelFrequency, VowelFrequency) => VowelFrequency` function with the "empty" value to reduce many items
down to a single total.

<Conversation>
<SkepticalSkunk>
Couldn't you have just counted the vowel frequency from a <code>string</code> of this article's text?
</SkepticalSkunk>

<Author>
Maybe, or maybe not! Maybe the string would be too big to fit in memory and we need to process in chunks. Maybe we're counting vowels for 
multiple articles (different files) and we want to parallelize the task. Maybe we run a "Vowel Counting as a Service" API and 
our customers send their content to us via websockets or some other asynchronous streaming technology. But maybe we could do it that
way too, I said this was a contrived example so I get a pass on this.
</Author>

<SkepticalSkunk>...</SkepticalSkunk>

<Author>...</Author>
</Conversation>

### Monoid - Why does it matter?

**practical** - The "empty" value is necessary for providing a starting value for the concatenation/reduction.
**conceptual** - Understanding the fundamental concepts of Semigroups and Monoids allows us to have a mental framework of 
breaking a large task into its smaller parts, and understanding the characteristics of each part.

## Functor

[fp-ts Functor documentation](https://gcanti.github.io/fp-ts/modules/Functor.ts.html)

### Functor - What is it?

A Functor is a thing with a value "inside" it. If that value has a type `A`, we would say that it is a `Functor<A>`.
If there is a `map` function takes a function as its parameter which is `A => B`. The `map` function returns a `Functor<B>`.

An important implication that may not be obvious is that the Functor is a "container"<Footnote>2<Footnote> of `A`, meaning
in some way or another it "contains" a value(s) that has type `A`.

[Functor diagram with a box of A]

Formally speaking, a Functor and its `map` function must satisfy the following two laws:

* Identity
* Composition

### Functor - Identity

The following must be true for something to be a `Functor` (from the fp-ts documentation):

```
F.map(fa, a => a) <-> fa
```

The fp-ts documentation uses an abbreviated notation. Here are the "translations" of this
notation to something that looks a little more like TypeScript:

* `F.map`: A `map` function within the `F` namespace that takes 2 arguments
* `fa`: `Functor<A>`, the first argument
* `a => a`: a function that is `A => A`, the second argument
* `<->`: is equivalent to (mathematical equivalence, not necessarily the same as JavaScript `===`)

This means that if we `map` a `Functor<A>` with a function that is `A => A`, 
then we still get a `Functor<A>` back (it might not be JavaScript `===` equivalent if it's a reference type, but
it's the same value mathematically).

<HistoryOwl>
The term "map" is [originally from mathematics](https://en.wikipedia.org/wiki/Map_(mathematics)), and 
[apparently](https://en.wikipedia.org/wiki/Map_(higher-order_function)#Language_comparison)
was originally discovered in the Lisp programming language in 1959.
</HistoryOwl>

### Functor - Composition

Composition is another mathematical concept. The following must also be true for something
to be a `Functor`, from the `fp-ts` documentation:

```
F.map(fa, a => bc(ab(a))) <-> F.map(F.map(fa, ab), bc)
```

We've gone over the notation for `F.map` and `fa` above. Here's the translation of the other notation:

* `ab`: An instance of a function that is `A => B`
* `bc`: An instance of a function that is `B => C`

Composition here means that to get from `Functor<A>` to `Functor<C>`, a Functor can either:

1. Be mapped with a function that is `A => B => C`; or
2. Be mapped with a function that is `A => B` and then mapped with another function that is `B => C`

### Functor - Why does it matter?

The `Functor` is a fundamental building block in our understanding of `fp-ts` and functional programming in general. 
Functors show up everywhere in JavaScript/TypeScript! The thing "inside" the "container" doesn't have to be a single value.
It could be a list of values (a JavaScript `Array` is a functor!) or stream of values (an [Observable](https://rxjs.dev/api/operators/map)
is a Functor), a value that may or may not exist ([Maybe](https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/)) or even 
a value that is yet to be calculated ([Task](https://gcanti.github.io/fp-ts/modules/Task.ts.html))!.

The Composition law also gives us a _practical_ benefit. If we know that we're working with a Functor (such as an `Array`), 
we can **compose** functions together to avoid mapping over the Functor multiple times (ex. iterating multiple times over an Array). 
Above, for #1 we called `map` once and for #2 we called `map` twice, and with composition we know that these are equivalent.

JavaScript is an [eagerly evaluated language](TODO), but other languages such as Rust (which probably got the idea from Haskell) 
will automatically apply this law to iterators.

```Rust
let orders: Vec<Order> = vec![ /* a list of customer orders */];

let discountedPrices: Vec<f64> = orders.iter()
  .map(getOrderPrice)
  .map(calculateDiscount)
  .collect()
```

Iterators in Rust are Functors and are lazily evaluated, so the compiler can automatically apply the optimization of **composing**
`getOrderPrice` and `calculateDiscount` on each element when it's evaluated rather than iterating through the list twice.

## 


# fp-ts Miracles


Several times throughout this article, I referred to a something as having been "discovered".
This might have seemed like strange wording, but it was intentional. Functional programming is rooted
in math, and mathematical concepts are often referred to as having been 'discovered'. 
For more discussion, especially to read different opinions, search "is math discovered or invented" 
in your favorite search engine.

This does not mean that the `fp-ts` library was "discovered", of course this library was specifically
implemented. 

<Footnote id={1}>
This article refers to both TypeScript and JavaScript but <strong>not</strong> interchangeably. It uses TypeScript when
discussing the type system, but JavaScript for language features such as arrays.
</Footnote>

<Footnote id={2}>
Container is a loose term but it'll have to do for now. One could argue that for a eventually calculated value (like a 
[Task](TODO), which might <strong>never</strong> be calculated), that it's not really a container. 
For the sake of this explanation, we'll continue to use the term "container".
</Footnote>
